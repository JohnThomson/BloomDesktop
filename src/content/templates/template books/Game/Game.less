@import (reference) "../../../../BloomBrowserUI/bloomUI.less";
// This was copied from Activity.less when we broke of the Games template.
// Some stuff can probably be removed.
// These items are visible by default (when not in the drag activity tool, especially
// when in the sign language or talking book tool), but not when we are in a tab
// or when "trying it" or running bloom player and in certain states

// These ones show in the Correct tab, or when the user has given a correct answer.
.drag-item-correct,
.drag-item-wrong {
    display: none;
}
.drag-activity-correct .drag-item-correct,
.drag-activity-wrong .drag-item-wrong {
    display: block;
}

// We want these only in the start tab, except for ones that are specific to the other tabs
.drag-activity-correct .bloom-textOverPicture:not(.drag-item-correct),
.drag-activity-wrong .bloom-textOverPicture:not(.drag-item-wrong),
.drag-activity-try-it .bloom-textOverPicture,
.drag-activity-solution .bloom-textOverPicture {
    img[src="placeHolder.png"] {
        display: none;
    }
}
[data-bubble-id] {
    display:flex;
    flex-direction:column;
    justify-content:center;
    .bloom-translationGroup {
        height: auto;
    }
}

// The slider can go away at runtime once everything is correctly placed.
.drag-activity-correct.drag-activity-try-it .bloom-activity-slider {
    display: none;
}

.activeButton {
    opacity:1;
}

.drag-activity-correct .bloom-page:not([data-activity="word-chooser-slider"]) {
    .bloom-textOverPicture:not(.drag-item-correct):not(.bloom-change-page-button),
    [data-target-of],
    .drag-item-random-sentence {
        opacity: 30%;
        pointer-events: none;
        cursor: unset;
    }
    .bloom-dragHandle {
        display: none;
    }
}
.drag-activity-wrong .bloom-page:not([data-activity="word-chooser-slider"]) {
    // Review: we want the change-page buttons to be visible and clickable always.
    // Should we have a distinct class for this, like bloom-all-tabs?
    .bloom-textOverPicture:not(.drag-item-wrong):not(.bloom-change-page-button),
    [data-target-of],
    .drag-item-random-sentence {
        opacity: 30%;
        pointer-events: none;
        cursor: unset;
    }
    .bloom-dragHandle {
        display: none;
    }
}
// Hide these buttons in try it mode, unless we already checked and got it wrong.
.drag-activity-try-it :not(.drag-activity-wrong) {
    .try-again-button,
    .show-correct-button {
        display: none;
    }
}

.drag-activity-try-it .drag-item-order-sentence {
    display: none;
}
.drag-activity-try-it .uibloomSourceTextsBubble {
    display:none !important;
}

.drag-item-random-sentence {
    display: flex;
    flex-wrap: wrap;
    row-gap: 5px;
    position: absolute;
}

// In the Wrong tab, or when the user has given a wrong answer.
// .drag-activity-start,
// .drag-activity-correct,
// .drag-activity-try-it {
//     &:not(.drag-activity-wrong) {
//         .drag-item-wrong {
//             display: none;
//         }
//     }
// }

.drag-activity-try-it {
    &.drag-activity-correct,
    &.drag-activity-wrong,
    &.drag-activity-solution {
        .check-button {
            // In the try-it tab when the user has given an answer, the check button does not apply.
            display: none;
        }
    }
}

.drag-activity-try-it.drag-activity-wrong {
    .try-again-button,
    .show-correct-button {
        // normal opacity in the situation where they actually apply and work
        .activeButton
    }
}

.drag-activity-try-it {
    #target-arrow,
    .bloom-dragHandle,
    .ui-resizable-handle {
        display: none;
    }
    .check-button {
        display: block; // displays in try-it mode initially...
    }
    &.drag-activity-wrong {
        .check-button {
            display: none; // but not if you already got it wrong
        }
        .try-again-button,
        .show-correct-button {
            display: block; // instead these show
        }
    }
    &.drag-activity-correct {
        .check-button {
            display: none; // but not if you already got it right
        }
    }
}

[data-target-of] {
    position: absolute;
    // above overlay canvas so we can drag it when the canvas is active
    z-index: @bubbleCanvasZIndex + 1;
    box-sizing: border-box;
}

// The rule above makes the target in front of the draggable it is the target-of.
// IIRC, there are good reasons not to give the draggable itself a z-index in edit mode.
// I think we can live with the target being in front in the other tabs, but
// when testing we need to be able to drag the bubble over the target.
// (But we don't want pictures that are just part of the background to be in front of targets.)
.drag-activity-try-it {
    .bloom-textOverPicture[data-bubble-id] {
        z-index: @bubbleCanvasZIndex + 2;
    }
    // Buttons for editing images and formatting text should not show in test mode.
    // Review: should we instead make special cases in the code that makes these buttons?
    .imageButton,
    #formatButton,
    .ui-tooltip-plain {
        // We need !important for the ui-tooltip-plain, which hides hint and source bubbles.
        // jquery tooltip puts display:block in the style of the element itself, so only
        // an !important rule can override it.
        display: none !important;
    }
    .cke_editable {
        cursor: default;
    }
    .marginBox {
        border: none;
        // repeat for specificity
        .bloom-imageContainer.bloom-imageContainer:after {
            border: none;
        }
    }
    .check-button {
        .activeButton;
    }
}

.bloom-page[data-activity="word-chooser-slider"] {
    --slider-height: 80px;
    --slider-item-height: 76px;
    .marginBox {
        border: 0 !important;
        img {
            // defeats a rule in basepage.css that otherwise prevents the image from filling the page.
            max-width: unset;
        }
    }
    .bloom-activity-slider {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        height: var(--slider-height);
        box-sizing: border-box;
        // Same as the canvas is enough to put in in front, since it comes later.
        z-index: @bubbleCanvasZIndex;
        .bloom-activity-slider-content {
            display: flex;
            height: 100%;
            position: absolute;
            top: 0;
        }
        .bloom-activity-slider-item {
            height: calc(100% - 4px);
            margin: 2px 22px;
            box-sizing: border-box;
            padding: 10px 3px;
            border-radius: 20px;
            min-width: calc(var(--slider-item-height) + 10px);
        }
        img {
            height: 100%;
            box-sizing: border-box;
            max-width: var(--slider-height);
        }
    }
    &:after {
        display: none; // no page number
    }
    .bloom-wordChoice {
        display: none; // only the active text box is shown
        &.bloom-activeTextBox {
            display: block;
        }
    }
    .bloom-textOverPicture {
        transition: opacity 1s ease-in-out;
    }
    .bloom-hideSliderImage {
        opacity: 0;
    }
    [data-img-txt="wrong"] {
        display: none;
        &.bloom-activePicture {
            display: block;
        }
    }
}
// If we're not going to show the targets during play, we indicate this by not giving them a background
// in other tabs.
.bloom-page[data-show-targets-during-play="false"] {
    [data-target-of] {
        background-color: transparent;
    }
}
// And don't show them at all in play mode.
.drag-activity-try-it .bloom-page[data-show-targets-during-play="false"] {
    [data-target-of] {
        // display:none would prevent the snap code from using them, since they would not have a location.
        visibility: hidden;
    }
}

@tan: #e9d9bd;
@paleTan: #f9e9cc;

// This is the beginning of Drag Activity Theme.
// The class activityBlueOnTan is applied to the activity page.
// Eventually, a different class would be applied when a different theme is chosen.
// The same nested classes should have different colors for each theme.
.activityBlueOnTan {
    --page-color: #e9d9bd;
    --target-color: #f9e9cc;
    --draggable-background-color: #2980bb;
    --draggable-color: white;
    --fixed-color: #fc8602;
    --slider-button-color: #2980bb;
    --slider-keyword-color: #902a90;
    --text-background: #75d0ee;
    &[data-activity="word-chooser-slider"] {
        [data-txt-img] {
            border: 8px solid var(--slider-keyword-color) !important;
            border-radius: 18px;
            background-color: var(--text-background);
        }
    }
    &.bloom-page {
        // need this for specificity
        background-color: var(--page-color);
    }
    .bloom-activity-slider {
        //background-color: yellow; // Todo
        background-image: linear-gradient(white, yellow);
        .bloom-activity-slider-item {
            border: 6px solid var(--slider-button-color);
            background-color: var(--text-background);
        }
    }
    .bloom-textOverPicture.draggable-text {
        background-color: var(--draggable-background-color);
        color: var(--draggable-color);
    }
    .drag-item-correct,
    .drag-item-wrong {
        .bloom-translationGroup {
            background-color: transparent;
            color: var(--fixed-color);
        }
    }
    .drag-item-order-word,
    .drag-item-order-sentence p {
        background-color: var(--draggable-background-color);
        color: var(--draggable-color);
        border-radius: 10px;
        padding: 0px 11px;
        margin-right: 5px;

    }

    .drag-item-order-sentence .bloom-editable {
        // If we want to put these back, we have to make it the full size. Currently the special padding is messing that up.
        border: none !important;
        outline: none !important;
        box-shadow: none !important;
        p {
            // This makes the original sentence take up about as much space as the broken-up words.
            word-spacing: 16px;
        }
    }

    .drag-item-order-word {
        // In bloom-player, cursor seems to be auto, which here gives us a text editing cursor.
        // Not sure why that doesn't happen in Try-it mode in Bloom desktop.
        // But anyway, we don't want it.
        cursor: default;
        box-sizing:border-box; // helpful when animating word moves by setting width.
    }

    [data-target-of] {
        border: dashed 2px var(--draggable-background-color);
        background-color: var(--target-color);

        &:focus {
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1),
                0 0 8px var(--draggable-background-color);
        }
    }

    .bloom-change-page-button {
        background-color: var(--draggable-background-color);
        color: var(--draggable-color);
        border-radius: 10px;
        padding: 3px 2px 2px 10px;
        box-sizing: border-box;
        // This puts it in front of other things so it can actually be clicked.
        z-index: @textOverPictureZIndex;
        // In bloom-player, cursor seems to be auto, which here gives us a text editing cursor.
        // Not sure why that doesn't happen in Try-it mode in Bloom desktop.
        // But anyway, we don't want it.
        cursor: default;
    }

    // We could add another common class to these three elements, but other themes
    // might want to style them differently.
    .check-button,
    .try-again-button,
    .show-correct-button {
        cursor: pointer;
        //font-size: 14px;
        font-weight: bold;
        //margin: 0 5px 5px 0;
        //padding: 5px 10px;
        text-decoration: none;
        //text-transform: uppercase;
        //transition: background-color 0.2s ease-in-out;
        // enough for a typical line of text and the decoration we're adding to make it look like a button;
        // tries to prevent initially coming up as overflowing, though may not succeed for other fonts.
        // Is there a better way?
        min-height: 36px;

        // This makes it look more like John's mockup, but it creates a stacking context,
        // and that interferes with setting the z-index on the handles and format button
        // to put them in front of the canvas even though they are outside the TOP box.
        //transform: skew(-5deg);

        // This should work, but it gets clipped at the bottom because the height
        // of the TOP box is set explicly in its style.
        // Instead I use the :after kludge below
        // border: 1px solid #0e2a8d !important;
        // border-radius: 4px;

        .bloom-translationGroup {
            background-color: var(--draggable-background-color);
            color: var(--draggable-color);
            height: 100%;
            width: 100%;
            border-radius: 4px;
            border-top: 5px solid #50d9eb;
            border-bottom: 4px solid #0e2a8d;
            text-shadow: 1px 0px black, 0px 2px black, -1px 0px black,
                0px -1px black;

            &:after {
                content: "";
                position: absolute;
                top: -5px;
                left: 0;
                // No idea why the -1px is needed here.
                width: calc(100% - 1px);
                // The +8px and the -4px above put this outside the TG's own border.
                height: calc(100% + 8px);
                border: 1px solid #0e2a8d;
                border-radius: 4px;
            }

            p:after {
                // This defeats something somewhere that otherwise adds a paragraph mark when clicked
                content: "";
            }
            // &:hover {
            //     background-color: #e6e6e6;
            // }
            // &:active {
            //     background-color: #ccc;
            // }
        }
    }
    .game-button {
        background-color: var(--draggable-background-color);
    }

    .activeButton {
        &:hover {
            border-color: @bloom-blue;
            &:active {
                border-color:black;
            }
        }
    }
}
.game-button,
.page-turn-button {
    position: absolute;
    z-index: @imageEditingButtonZIndex;
    border-color:transparent;
}

.game-button {
    height: 36px;
    width: 50px;
    opacity: 0.3;
}
.page-turn-button {
    background-color: transparent;
    opacity: 10%;
}

.turn-left img {
    transform: rotate(180deg);
}
